<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>PA2020 / JOISC2020 / eJOI2021 选做 | Sol 1</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="教练布置的作业。">
<meta property="og:type" content="article">
<meta property="og:title" content="PA2020 &#x2F; JOISC2020 &#x2F; eJOI2021 选做">
<meta property="og:url" content="http://soly5tic.github.io/2023/06/05/pa2020-joisc2020-ejoi2021-upsolve/index.html">
<meta property="og:site_name" content="Sol 1">
<meta property="og:description" content="教练布置的作业。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-06-04T16:00:00.000Z">
<meta property="article:modified_time" content="2024-02-12T14:32:50.325Z">
<meta property="article:author" content="Sol 1">
<meta property="article:tag" content="题解">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Sol 1" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon_32.ico">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Sol 1</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://soly5tic.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-pa2020-joisc2020-ejoi2021-upsolve" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/05/pa2020-joisc2020-ejoi2021-upsolve/" class="article-date">
  <time class="dt-published" datetime="2023-06-04T16:00:00.000Z" itemprop="datePublished">2023-06-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      PA2020 / JOISC2020 / eJOI2021 选做
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>教练布置的作业。</p>
<span id="more"></span>
<h2 id="JOISC2020-カメレオンの恋">[JOISC2020] カメレオンの恋</h2>
<p>考虑建一个无向图，$u,v$ 之间有边当且仅当询问 ${u,v}$ 的结果为 $1$。那么对于一对双向奔赴的关系，则两侧的点的度数均为 $1$；其他点的度数均为 $3$。</p>
<p>由于自己和自己喜欢的一定不同色，所以对于 1 度点，直接找唯一的相邻的边就是答案。对于一个 3 度点，经过枚举可以发现如果从这个大小为 4 的邻域中询问 3 个点，那么当且仅当询问到「自己、喜欢自己的、和自己同色的」时答案为 1，于是可以找到自己喜欢的。</p>
<p>所以在得到图之后，可以使用至多 $3000$ 次操作找出所有的喜欢关系，于是可以得到答案。问题变为使用至多 $17000$ 次操作建出该无向图。</p>
<p>考虑一个暴力：维护一个点集 $S$，初始为空。依次考虑点 $u$，如果询问 $S\cup{u}$ 的结果是 $|S|+1$，说明 $u$ 到 $S$ 中没有边，将 $u$ 加入 $S$。遍历所有点后，对于所有不在 $S$ 中的点（设这些点构成点集 $T$），可以在 $S$ 内部二分找到其所有连向 $S$ 内部的边。最后，我们确定 $S$ 内部没有边，并找到了所有 $S,T$ 之间的边，然后直接对 $T$ 递归做。</p>
<p>下面我们证明这个暴力足以通过这道题。</p>
<p>首先每一个点的度数最多是 3，于是有 $3|S|\geq |T|$，变形得 $|T|\leq \dfrac{3}{4}(|S|+|T|)$，于是每次递归问题规模至少缩小到原来的 $\dfrac{3}{4}$。因此对大小为 $n$ 的集合，递归过程消耗的查询次数满足 $T(n)=n+T\left(\dfrac{3}{4}n\right)$，可以解得 $T(n)=4n$，于是这部分消耗 $T(2n)=8n$ 的代价。</p>
<p>同时每条边只贡献一次二分的代价，于是消耗 $1500\log n$。</p>
<p>这样算出来需要 $19000$ 次，仍然过大。但是我们不难观察到这个 $8n$ 和 $1500\log n$ 之间存在相互制约关系。具体来说，让边数代价最大的情况显然是第一层递归直接找到所有边。设第一层找到的独立集为 $S$，那么代价是 $1500\log |S|+1000+4(1000-|S|)$（log 不需要上取整是因为每个点度数为 3 保证二分的终点分布足够均匀），解出最大值是 $16500$ 左右，于是总交互次数就被控制到了 $19500$ 以下，于是就可以通过。</p>
<p>时间复杂度 $O(n^2\log n)$，交互次数 $O(n\log n)$。实际最大点交互次数不到 $19000$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> So1stice &#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> MXN = <span class="number">1005</span>;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">bool</span> suki[MXN][MXN], vis[MXN];</span><br><span class="line">	vector &lt;<span class="type">int</span>&gt; g[MXN];</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">findEdge</span><span class="params">(<span class="type">const</span> vector &lt;<span class="type">int</span>&gt; &amp;t, <span class="type">int</span> bl, <span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">		vector &lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = bl;i &lt; t.<span class="built_in">size</span>();i++) tmp.<span class="built_in">push_back</span>(t[i]);</span><br><span class="line">		tmp.<span class="built_in">push_back</span>(s);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">Query</span>(tmp) == tmp.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="type">int</span> l = bl, r = t.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">			<span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			vector &lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = l;i &lt;= mid;i++) tmp.<span class="built_in">push_back</span>(t[i]);</span><br><span class="line">			tmp.<span class="built_in">push_back</span>(s);</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">Query</span>(tmp) != tmp.<span class="built_in">size</span>()) r = mid;</span><br><span class="line">			<span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> l;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">buildGraph</span><span class="params">(<span class="type">const</span> vector &lt;<span class="type">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (v.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">		vector &lt;<span class="type">int</span>&gt; iso, nxt;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> x : v) &#123;</span><br><span class="line">			iso.<span class="built_in">push_back</span>(x);</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">Query</span>(iso) &lt; iso.<span class="built_in">size</span>()) &#123;</span><br><span class="line">				iso.<span class="built_in">pop_back</span>();</span><br><span class="line">				nxt.<span class="built_in">push_back</span>(x);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> x : nxt) &#123;</span><br><span class="line">			<span class="type">int</span> p = <span class="number">0</span>, l;</span><br><span class="line">			<span class="keyword">while</span> ((l = <span class="built_in">findEdge</span>(iso, p, x)) != <span class="number">-1</span>) &#123;</span><br><span class="line">				g[x].<span class="built_in">push_back</span>(iso[l]);</span><br><span class="line">				g[iso[l]].<span class="built_in">push_back</span>(x);</span><br><span class="line">				p = l + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">buildGraph</span>(nxt);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		vector &lt;<span class="type">int</span>&gt; bg;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">2</span> * n;i++) bg.<span class="built_in">push_back</span>(i);</span><br><span class="line">		<span class="built_in">buildGraph</span>(bg);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">2</span> * n;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (g[i].<span class="built_in">size</span>() == <span class="number">3</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>;a &lt; g[i].<span class="built_in">size</span>();a++) &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> b = a + <span class="number">1</span>;b &lt; g[i].<span class="built_in">size</span>();b++) &#123;</span><br><span class="line">						vector &lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">						tmp.<span class="built_in">push_back</span>(g[i][a]); tmp.<span class="built_in">push_back</span>(i); tmp.<span class="built_in">push_back</span>(g[i][b]);</span><br><span class="line">						<span class="keyword">if</span> (<span class="built_in">Query</span>(tmp) == <span class="number">1</span>) &#123;</span><br><span class="line">							suki[g[i][<span class="number">0</span>] + g[i][<span class="number">1</span>] + g[i][<span class="number">2</span>] - g[i][a] - g[i][b]][i] = <span class="number">1</span>;</span><br><span class="line">							suki[i][g[i][<span class="number">0</span>] + g[i][<span class="number">1</span>] + g[i][<span class="number">2</span>] - g[i][a] - g[i][b]] = <span class="number">1</span>;</span><br><span class="line">							<span class="keyword">goto</span> done;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			done:;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">2</span> * n;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> v : g[i]) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!suki[i][v] &amp;&amp; !suki[v][i]) &#123;</span><br><span class="line">						<span class="built_in">Answer</span>(v, i);</span><br><span class="line">						vis[i] = vis[v] = <span class="number">1</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">	So1stice::n = N;</span><br><span class="line">	So1stice::<span class="built_in">Work</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P8170-eJOI2021-Waterfront">P8170 [eJOI2021] Waterfront</h2>
<p>考虑到树的高度逐渐增加，因此如果后面的某一天没有砍满 $k$ 次，那么把前面的某一天里面的一次调整到后面的这一天一定合法。</p>
<p>因此可以贪心地尽量在前面砍，得到一个可能不合法的方案。如果对所有 $i$ 满足最后 $i$ 天砍了少于 $ki$ 次，则方案可以调整出合法方案，否则方案不能调整出合法方案。</p>
<p>二分之后进行该贪心，复杂度 $O(NM\log (h+Md))$，无法通过。</p>
<p>考虑按照不进行砍树的情况下达到的最终高度，每次砍最大的。使用堆维护复杂度 $O(Mk\log N)$。考虑到每次减的值是一个定值，因此可以排序完，每次减一个前缀 $[1,i]$，当 $i+1$ 的高度小于等于 $i$ 的高度时暴力将 $i$ 插入这个前缀，即可做到 $O(Mk)$。</p>
<p>然后预处理出每一个位置尽量在前面砍，每一次分别砍在什么时候。直接做就是 $O(N+Mk)$。</p>
<p>最后就是按照上面那个顺序一个一个砍，砍到某一个后缀次数太多之后就停止，记录每一棵树砍了几次，求出答案。使用树状数组倍增可以 $O(Mk\log M)$，也可使用并查集维护后继做到 $O(Mk\alpha(M))$。</p>
<p>总时间复杂度 $O(N\log N+Mk\alpha(M))$ 或者 $O(N\log N+Mk\log M)$，空间复杂度 $O(Mk)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m + <span class="number">1</span>;i++) fa[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetRoot</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[v] == v) <span class="keyword">return</span> v;</span><br><span class="line">    <span class="keyword">return</span> fa[v] = <span class="built_in">GetRoot</span>(fa[v]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">GetRoot</span>(x), v = <span class="built_in">GetRoot</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (u != v) fa[u] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        cin &gt;&gt; h[i] &gt;&gt; d[i];</span><br><span class="line">        f[i] = h[i] + d[i] * m;</span><br><span class="line">        idx[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(idx + <span class="number">1</span>, idx + n + <span class="number">1</span>, [&amp;](<span class="type">const</span> <span class="type">int</span> &amp;x, <span class="type">const</span> <span class="type">int</span> &amp;y) &#123;</span><br><span class="line">        <span class="keyword">return</span> f[x] &gt; f[y];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cut.<span class="built_in">size</span>() &lt;= m * k) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = cut.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= r;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[idx[i]] &gt;= x) &#123;</span><br><span class="line">                f[idx[i]] -= x;</span><br><span class="line">                cnt[idx[i]]++;</span><br><span class="line">                cut.<span class="built_in">push_back</span>(idx[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cut.<span class="built_in">size</span>() == tmp) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n &amp;&amp; f[idx[r]] &lt;= f[idx[r + <span class="number">1</span>]]) &#123;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="type">int</span> p = r;</span><br><span class="line">            <span class="keyword">while</span> (p &gt; <span class="number">1</span> &amp;&amp; f[idx[p - <span class="number">1</span>]] &lt; f[idx[p]]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(idx[p - <span class="number">1</span>], idx[p]);</span><br><span class="line">                p--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for (int x : cut) cout &lt;&lt; x &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="type">int</span> cur = h[i] + d[i], cd = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= cnt[i];j++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur &lt; x) &#123;</span><br><span class="line">                cur += d[i];</span><br><span class="line">                cd++;</span><br><span class="line">            &#125;</span><br><span class="line">            cur -= x;</span><br><span class="line">            tim[i].<span class="built_in">push_back</span>(cd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) lft[i] = k;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : cut) &#123;</span><br><span class="line">        <span class="type">int</span> pos = <span class="built_in">GetRoot</span>(tim[x][cnt[x]]);</span><br><span class="line">        <span class="keyword">if</span> (pos &gt; m) <span class="keyword">break</span>;</span><br><span class="line">        lft[pos]--;</span><br><span class="line">        <span class="keyword">if</span> (lft[pos] == <span class="number">0</span>) <span class="built_in">Merge</span>(pos, pos + <span class="number">1</span>);</span><br><span class="line">        cnt[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) ans = <span class="built_in">max</span>(ans, h[i] + d[i] * m - cnt[i] * x);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P8169-eJOI2021-Dungeons">P8169 [eJOI2021] Dungeons</h2>
<p>整体想法其实很直接：</p>
<ul>
<li>玩家记录下来自己已经看到的所有位置的信息，然后尝试利用这些信息来推断出自己在地图的哪些位置。</li>
<li>假设玩家可以推断出自己的起点是所有起点的一个子集 $S$ 里面的某一个。</li>
<li>玩家为了尝试获得更多信息来具体推断自己的起点在 $S$ 里面的哪一个位置，需要向外找安全的位置扩展。具体来说，需要找到一个格子满足：
<ul>
<li>它与玩家已经走到过的格子相邻；</li>
<li>假设这个格子与起点的相对位置是 $(x,y)$。玩家为了保证自己不被炸到，需要保证对于 $S$ 里面的任意一个起点，均满足与该起点的相对位置是 $(x,y)$ 的格子是安全的。后续我们称这样的格子对于 $S$ 绝对安全。</li>
</ul>
</li>
<li>当玩家无法找到这样的格子时，游戏结束，玩家获得自己能走到的范围内的所有金币。</li>
<li>答案即为所有游戏结束的情况中，玩家获得金币数的最小值。</li>
</ul>
<p>当然如果直接实现上述过程肯定写起来非常阴间，而且复杂度不一定对。</p>
<p>因此我们简化一下这个过程。注意到 $S$ 一旦变化为 $S’$，则新的 $S’$ 一定包含于 $S$。因此对于 $S$ 绝对安全的格子对于 $S’$ 也一定绝对安全。所以可以让玩家在此时直接丢弃所有信息重新开始扩展，也可以求得答案。</p>
<p>从而我们实现如下过程：</p>
<ul>
<li>假设目前起点集合是 $S$。</li>
<li>从起点开始 BFS 扩展，需要满足扩展到的点对于 $S$ 绝对安全。</li>
<li>当无法扩展时，枚举已经看到的所有的点（即扩展到的点和它的外面一圈）。</li>
<li>如果某一个位置（设其相对起点的位置是 $(x,y)$）满足：存在 $s_1,s_2\in S$，使得相对 $s_1$ 的位置是 $(x,y)$ 的位置 $p_1$ 和相对 $s_2$ 的位置是 $(x,y)$ 的位置 $p_2$ 在玩家看起来不相同，则可以依照这个点的视野差异分裂 $S$ 并递归进行该过程，并返回递归的两个分叉的返回值的最小值。</li>
<li>如果无法分裂 $S$，统计扩展到多少个金币，返回该值。</li>
</ul>
<p>最终结果就是对所有起点构成的集合进行上述过程的返回值。</p>
<p>直接实现，复杂度 $O(nmS^2)$：每次 BFS 扩展复杂度 $O(nmS)$，同时集合分裂 $S$ 次。</p>
<p>这个复杂度无法通过本题。考虑到瓶颈有两个，分别是：</p>
<ol>
<li>BFS 扩展时判断一个点是否绝对安全，这可以压位：对于每一个 $(x,y)$ 保存一个 64 位整数，第 $i$ 位存储相对第 $i$ 个起点的位置是 $(x,y)$ 的位置是否安全（“安全”指不是 <code>X</code> 和 <code>#</code>），然后就可以用一次位运算判断。</li>
<li>判断一个点是否可以分裂 $S$。这同样可以压位：一个点有三种视觉效果（障碍、空地、金币），对于每一个 $(x,y)$ 保存三个 64 位整数，第 $i$ 位存储相对第 $i$ 个起点的位置是 $(x,y)$ 的位置的视觉效果是不是障碍（空地、金币），然后就可以用三次位运算判断。</li>
</ol>
<p>进行如上优化后，一轮过程的复杂度下降至 $O(nm)$，总复杂度即下降至 $O(nmS)$ 即可通过。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Next[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Sight[<span class="number">9</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="type">char</span> mp[<span class="number">405</span>][<span class="number">405</span>], rel[<span class="number">60</span>][<span class="number">815</span>][<span class="number">815</span>];</span><br><span class="line"><span class="type">int</span> n, m, x[<span class="number">60</span>], y[<span class="number">60</span>], s;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> saf[<span class="number">815</span>][<span class="number">815</span>], sig[<span class="number">815</span>][<span class="number">815</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">815</span>][<span class="number">815</span>], isg[<span class="number">815</span>][<span class="number">815</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;j++) &#123;</span><br><span class="line">            cin &gt;&gt; mp[i][j];</span><br><span class="line">            <span class="keyword">if</span> (mp[i][j] == <span class="string">&#x27;S&#x27;</span>) &#123;</span><br><span class="line">                x[s] = i; y[s] = j;</span><br><span class="line">                s++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Prefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>;k &lt; s;k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;j++) rel[k][i - x[k] + <span class="number">402</span>][j - y[k] + <span class="number">402</span>] = mp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>;k &lt; s;k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">810</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">810</span>;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rel[k][i][j] == <span class="string">&#x27;X&#x27;</span> || rel[k][i][j] == <span class="string">&#x27;#&#x27;</span>) saf[i][j] |= (<span class="number">1ll</span> &lt;&lt; k);</span><br><span class="line">                <span class="keyword">if</span> (rel[k][i][j] == <span class="string">&#x27;X&#x27;</span> || rel[k][i][j] == <span class="string">&#x27;.&#x27;</span> || rel[k][i][j] == <span class="string">&#x27;S&#x27;</span>) sig[i][j][<span class="number">0</span>] |= (<span class="number">1ll</span> &lt;&lt; k);</span><br><span class="line">                <span class="keyword">if</span> (rel[k][i][j] == <span class="string">&#x27;#&#x27;</span>) sig[i][j][<span class="number">1</span>] |= (<span class="number">1ll</span> &lt;&lt; k);</span><br><span class="line">                <span class="keyword">if</span> (rel[k][i][j] == <span class="string">&#x27;o&#x27;</span>) sig[i][j][<span class="number">2</span>] |= (<span class="number">1ll</span> &lt;&lt; k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Work</span><span class="params">(<span class="type">long</span> <span class="type">long</span> sta)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;work &quot; &lt;&lt; sta &lt;&lt; endl;</span></span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(isg, <span class="number">0</span>, <span class="built_in">sizeof</span>(isg));</span><br><span class="line">    queue &lt;pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">402</span>, <span class="number">402</span>));</span><br><span class="line">    vis[<span class="number">402</span>][<span class="number">402</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> x = que.<span class="built_in">front</span>().first, y = que.<span class="built_in">front</span>().second;</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>;k &lt; <span class="number">4</span>;k++) &#123;</span><br><span class="line">            <span class="type">int</span> tx = x + Next[k][<span class="number">0</span>], ty = y + Next[k][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (tx &lt; <span class="number">1</span> || tx &gt; <span class="number">810</span> || ty &lt; <span class="number">1</span> || ty &gt; <span class="number">810</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (sta &amp; saf[tx][ty]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (vis[tx][ty]) <span class="keyword">continue</span>;</span><br><span class="line">            vis[tx][ty] = <span class="number">1</span>;</span><br><span class="line">            que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(tx, ty));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">810</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">810</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i][j]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>;k &lt; <span class="number">9</span>;k++) &#123;</span><br><span class="line">                    <span class="type">int</span> tx = i + Sight[k][<span class="number">0</span>], ty = j + Sight[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (tx &lt; <span class="number">1</span> || tx &gt; <span class="number">810</span> || ty &lt; <span class="number">1</span> || ty &gt; <span class="number">810</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    isg[tx][ty] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">810</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">810</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isg[i][j]) &#123;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>;c &lt; <span class="number">3</span>;c++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((sig[i][j][c] &amp; sta) != <span class="number">0</span> &amp;&amp; (sig[i][j][c] &amp; sta) != sta) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">Work</span>((sig[i][j][c] &amp; sta)), <span class="built_in">Work</span>(sta ^ (sig[i][j][c] &amp; sta)));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">810</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">810</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i][j] &amp;&amp; (sig[i][j][<span class="number">2</span>] &amp; sta) == sta) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Read</span>();</span><br><span class="line">    <span class="built_in">Prefix</span>();</span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;pass&quot; &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">Work</span>((<span class="number">1ll</span> &lt;&lt; s) - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P9103-PA2020-Bardzo-skomplikowany-test">P9103 [PA2020] Bardzo skomplikowany test</h2>
<p>考虑如果第一棵树的根是 $a$，第二棵树的根是 $b$。不妨假设 $a&lt;b$，另一个方向对称。</p>
<p>此时我们为了把 $b$ 移动到根，我们显然需要将 $a+1\sim b-1$ 的所有点移动到 $a,b$ 之间，形成一条 $a-(a+1)-(a+2)-\cdots-(b-1)-b$ 的链，然后将 $b$ 转到根。</p>
<p>此时树根的两侧是独立子问题，递归做即可。</p>
<hr>
<p>为什么这么做是最优的？</p>
<p>考虑：</p>
<ol>
<li>如果考虑树的父亲序列，则题目中的操作一定只会同时改变中序遍历上相邻的两个点的父亲。</li>
<li>复位根必须要求形成一条 $a-(a+1)-(a+2)-\cdots-(b-1)-b$ 的链，从而一切会改变 $a,b$ 以及中间的任何一个点的，且不属于构建这条链的过程的结构改变都将被覆盖，没有必要。</li>
<li>其余改变与构建链的过程独立，可以交换到构建链后面。</li>
</ol>
<hr>
<p>然后就是考虑如何构建这条链。</p>
<p>这个唯一性很强：从 $a$ 开始递归往右走直到走到一个 $\geq k$ 的点，设走到 $a-c_1-c_2-\cdots-c_k$。然后将 $c_1$ 的左子树修改成一条左链，然后往右转直到左子树消失。然后对 $c_2,\cdots,c_k$ 同样处理。</p>
<hr>
<p>然后再考虑如何把一个子树修改成左链/右链。（右链是因为需要对称）</p>
<p>这个更直接，把左子树修改成左链，右子树修改成右链，然后依照需求往左/往右转。</p>
<p>这个修改次数就可以直接 dp 了。设 $f_{u,0/1}$ 表示修改成左链/右链的方案数，$s_u$ 是 $u$ 的子树的大小。转移：</p>
<ul>
<li>$f_{u,0}\leftarrow f_{l,0}+f_{r,1}+s_l$</li>
<li>$f_{u,1}\leftarrow f_{l,0}+f_{r,1}+s_r$</li>
</ul>
<p>其中 $l,r$ 是 $u$ 的左右孩子。</p>
<hr>
<p>考虑算答案。</p>
<p>考虑我们复位根之后剩下的是包含根的一条链，两头接上 <strong>原本就在 $a$ 中存在</strong> 的子树。</p>
<p>所以我们就可以将 $a$ 的形态记作一棵子树上面接一条左链/右链，且这个链上的点是一个连续区间。</p>
<p>然后注意到上面那个“从 $a$ 开始递归往右走直到走到一个 $\geq k$ 的点”的过程不会多次搜到同一个点，于是直接暴力做，复杂度就是 $O(n)$，就做完了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, als[N], ars[N], bls[N], brs[N], alt[N], blt[N], art[N], brt[N], fa[N], fb[N], rta, rtb;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dpa[N][<span class="number">2</span>], dpb[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">qread</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        fa[i] = <span class="built_in">qread</span>();</span><br><span class="line">        <span class="keyword">if</span> (fa[i] != <span class="number">-1</span> &amp;&amp; fa[i] &lt; i) ars[fa[i]] = i;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (fa[i] != <span class="number">-1</span> &amp;&amp; fa[i] &gt; i) als[fa[i]] = i;</span><br><span class="line">        <span class="keyword">else</span> rta = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        fb[i] = <span class="built_in">qread</span>();</span><br><span class="line">        <span class="keyword">if</span> (fb[i] != <span class="number">-1</span> &amp;&amp; fb[i] &lt; i) brs[fb[i]] = i;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (fb[i] != <span class="number">-1</span> &amp;&amp; fb[i] &gt; i) bls[fb[i]] = i;</span><br><span class="line">        <span class="keyword">else</span> rtb = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">DfsA</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    alt[u] = art[u] = u;</span><br><span class="line">    dpa[u][<span class="number">0</span>] = dpa[u][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (als[u]) &#123;</span><br><span class="line">        <span class="built_in">DfsA</span>(als[u]);</span><br><span class="line">        alt[u] = <span class="built_in">min</span>(alt[u], alt[als[u]]);</span><br><span class="line">        dpa[u][<span class="number">0</span>] += dpa[als[u]][<span class="number">0</span>];</span><br><span class="line">        dpa[u][<span class="number">1</span>] += art[als[u]] - alt[als[u]] + <span class="number">1</span> + dpa[als[u]][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ars[u]) &#123;</span><br><span class="line">        <span class="built_in">DfsA</span>(ars[u]);</span><br><span class="line">        art[u] = <span class="built_in">max</span>(art[u], art[ars[u]]);</span><br><span class="line">        dpa[u][<span class="number">0</span>] += art[ars[u]] - alt[ars[u]] + <span class="number">1</span> + dpa[ars[u]][<span class="number">1</span>];</span><br><span class="line">        dpa[u][<span class="number">1</span>] += dpa[ars[u]][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">DfsB</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    blt[u] = brt[u] = u;</span><br><span class="line">    dpb[u][<span class="number">0</span>] = dpb[u][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (bls[u]) &#123;</span><br><span class="line">        <span class="built_in">DfsB</span>(bls[u]);</span><br><span class="line">        blt[u] = <span class="built_in">min</span>(blt[u], blt[bls[u]]);</span><br><span class="line">        dpb[u][<span class="number">0</span>] += dpb[bls[u]][<span class="number">0</span>];</span><br><span class="line">        dpb[u][<span class="number">1</span>] += brt[bls[u]] - blt[bls[u]] + <span class="number">1</span> + dpb[bls[u]][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (brs[u]) &#123;</span><br><span class="line">        <span class="built_in">DfsB</span>(brs[u]);</span><br><span class="line">        brt[u] = <span class="built_in">max</span>(brt[u], brt[brs[u]]);</span><br><span class="line">        dpb[u][<span class="number">0</span>] += brt[brs[u]] - blt[brs[u]] + <span class="number">1</span> + dpb[brs[u]][<span class="number">1</span>];</span><br><span class="line">        dpb[u][<span class="number">1</span>] += dpb[brs[u]][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    dpb[u][<span class="number">0</span>] %= mod; dpb[u][<span class="number">1</span>] %= mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">Solve</span><span class="params">(<span class="type">int</span> nda, <span class="type">int</span> sgl, <span class="type">int</span> sgr, <span class="type">int</span> flg, <span class="type">int</span> ndb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sgl &gt; sgr) &#123;</span><br><span class="line">        sgl = sgr = <span class="number">-1</span>;</span><br><span class="line">        flg = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (flg == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nda == ndb) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (als[nda]) ans += <span class="built_in">Solve</span>(als[nda], <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, bls[ndb]);</span><br><span class="line">            <span class="keyword">if</span> (ars[nda]) ans += <span class="built_in">Solve</span>(ars[nda], <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, brs[ndb]);</span><br><span class="line">            res = ans % mod;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nda &lt; ndb) &#123;</span><br><span class="line">            <span class="type">int</span> u = nda;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (u &lt; ndb) &#123;</span><br><span class="line">                u = ars[u];</span><br><span class="line">                <span class="keyword">if</span> (als[u]) ans += dpa[als[u]][<span class="number">0</span>] + art[als[u]] - alt[als[u]] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> l = nda, r = u;</span><br><span class="line">            ans += ndb - nda;</span><br><span class="line">            <span class="keyword">if</span> (als[nda]) ans += <span class="built_in">Solve</span>(als[nda], l, ndb - <span class="number">1</span>, <span class="number">2</span>, bls[ndb]);</span><br><span class="line">            <span class="keyword">else</span> ans += dpb[bls[ndb]][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (ars[u]) ans += <span class="built_in">Solve</span>(ars[u], ndb + <span class="number">1</span>, r, <span class="number">1</span>, brs[ndb]);</span><br><span class="line">            <span class="keyword">else</span> ans += dpb[brs[ndb]][<span class="number">1</span>];</span><br><span class="line">            res = ans % mod;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nda &gt; ndb) &#123;</span><br><span class="line">            <span class="type">int</span> u = nda;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (u &gt; ndb) &#123;</span><br><span class="line">                u = als[u];</span><br><span class="line">                <span class="keyword">if</span> (ars[u]) ans += dpa[ars[u]][<span class="number">1</span>] + art[ars[u]] - alt[ars[u]] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> l = u, r = nda;</span><br><span class="line">            ans += nda - ndb;</span><br><span class="line">            <span class="keyword">if</span> (als[u]) ans += <span class="built_in">Solve</span>(als[u], l, ndb - <span class="number">1</span>, <span class="number">2</span>, bls[ndb]);</span><br><span class="line">            <span class="keyword">else</span> ans += dpb[bls[ndb]][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (ars[nda]) ans += <span class="built_in">Solve</span>(ars[nda], ndb + <span class="number">1</span>, r, <span class="number">1</span>, brs[ndb]);</span><br><span class="line">            <span class="keyword">else</span> ans += dpb[brs[ndb]][<span class="number">1</span>];</span><br><span class="line">            res = ans % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flg == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sgl &lt;= ndb &amp;&amp; ndb &lt;= sgr) res = (ndb - sgl + dpb[bls[ndb]][<span class="number">0</span>] + <span class="built_in">Solve</span>(nda, ndb + <span class="number">1</span>, sgr, <span class="number">1</span>, brs[ndb])) % mod;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> u = nda;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (u &lt; ndb) &#123;</span><br><span class="line">                <span class="keyword">if</span> (als[u]) ans += dpa[als[u]][<span class="number">0</span>] + art[als[u]] - alt[als[u]] + <span class="number">1</span>;</span><br><span class="line">                u = ars[u];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (als[u]) ans += dpa[als[u]][<span class="number">0</span>] + art[als[u]] - alt[als[u]] + <span class="number">1</span>;</span><br><span class="line">            u = ars[u];</span><br><span class="line">            <span class="keyword">if</span> (u == <span class="number">0</span>) res = (ans + dpb[ndb][<span class="number">1</span>]) % mod;</span><br><span class="line">            <span class="keyword">else</span> res = (ans + <span class="built_in">Solve</span>(u, sgl, fa[u], <span class="number">1</span>, ndb)) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sgl &lt;= ndb &amp;&amp; ndb &lt;= sgr) res = (sgr - ndb + dpb[brs[ndb]][<span class="number">1</span>] + <span class="built_in">Solve</span>(nda, sgl, ndb - <span class="number">1</span>, <span class="number">2</span>, bls[ndb])) % mod;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> u = nda;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (u &gt; ndb) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ars[u]) ans += dpa[ars[u]][<span class="number">1</span>] + art[ars[u]] - alt[ars[u]] + <span class="number">1</span>;</span><br><span class="line">                u = als[u];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ars[u]) ans += dpa[ars[u]][<span class="number">1</span>] + art[ars[u]] - alt[ars[u]] + <span class="number">1</span>;</span><br><span class="line">            u = als[u];</span><br><span class="line">            <span class="keyword">if</span> (u == <span class="number">0</span>) res = (ans + dpb[ndb][<span class="number">0</span>]) % mod;</span><br><span class="line">            <span class="keyword">else</span> res = (ans + <span class="built_in">Solve</span>(u, fa[u], sgr, <span class="number">2</span>, ndb)) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (res % mod + mod) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P9096-PA2020-Sen-o-podboju">P9096 [PA2020] Sen o podboju</h2>
<p>数据随机自然是乱搞。</p>
<p>考虑一个暴力 dp：$f_{i,j,k}$ 表示 $i$ 子树，断了 $j$ 条边，根所在连通块的 $a$ 的和是 $k$，最小的连通块平方和。</p>
<p>对于边 $(u,v)$，转移是：</p>
<ul>
<li>$f_{u,x,y}+f_{v,p,q}+2yq\rightarrow f_{u,x+p,y+q}'$（不断 $u,v$ 边）</li>
<li>$f_{u,x,y}+f_{v,p,q}\rightarrow f_{u,x+p+1,y}'$（断 $u,v$ 边）</li>
</ul>
<p>复杂度 $O(n^2w^2)$，显然过不了。</p>
<p>考虑剪枝，对于 $k_1&lt;k_2$，如果 $f_{i,j,k_1}&lt;f_{i,j,k_2}$，那么 $k_2$ 显然没用。</p>
<p>于是我们对每一个 $f_{i,j}$ 开个 vector 存所有有用的 $k$，每次暴力枚举两个 $k$ 转移，转移完暴力对所有 vector 按 $k$ 排序再暴力删掉所有没用的点。</p>
<p>然后这个算法就直接以最大点不到半秒的优异表现通过了这道题！</p>
<p>复杂度我不会严格分析，不过感性理解的话，假定 dp 数组在树和点权都均匀随机的情况下足够均匀随机，那么根据前缀最大值个数期望（也就是笛卡尔树深度期望），复杂度可以分析为 $O(n^2\log^2 w)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">305</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to, nxt;</span><br><span class="line">    <span class="built_in">Edge</span>() &#123;</span><br><span class="line">        nxt = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n, hd[N], siz[N], pnt;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[N];</span><br><span class="line">Edge e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line">vector &lt;pair &lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">long</span> <span class="type">long</span>&gt; &gt; dp[N][N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[++pnt].to = v;</span><br><span class="line">    e[pnt].nxt = hd[u];</span><br><span class="line">    hd[u] = pnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">qread</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = <span class="built_in">qread</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="built_in">qread</span>(), v = <span class="built_in">qread</span>();</span><br><span class="line">        <span class="built_in">AddEdge</span>(u, v); <span class="built_in">AddEdge</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    siz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n;i++) dp[u][i].<span class="built_in">clear</span>();</span><br><span class="line">    dp[u][<span class="number">0</span>].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(a[u], a[u] * a[u]));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = hd[u];~i;i = e[i].nxt) &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v != fa) &#123;</span><br><span class="line">            <span class="built_in">Dfs</span>(v, u);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt;= siz[v];i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt;= siz[u];j++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> x : dp[v][i]) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">auto</span> y : dp[u][j]) &#123;</span><br><span class="line">                            tmp[i + j].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(x.first + y.first, x.second + y.second + <span class="number">2</span> * x.first * y.first));</span><br><span class="line">                            tmp[i + j + <span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(y.first, x.second + y.second));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            siz[u] += siz[v];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt;= siz[u];i++) &#123;</span><br><span class="line">                dp[u][i].<span class="built_in">clear</span>();</span><br><span class="line">                <span class="built_in">sort</span>(tmp[i].<span class="built_in">begin</span>(), tmp[i].<span class="built_in">end</span>());</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> mnv = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; tmp[i].<span class="built_in">size</span>();j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tmp[i][j].second &lt; mnv) &#123;</span><br><span class="line">                        mnv = tmp[i][j].second;</span><br><span class="line">                        dp[u][i].<span class="built_in">push_back</span>(tmp[i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp[i].<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P9108-PA2020-Malowanie-plotu">P9108 [PA2020] Malowanie płotu</h2>
<p>考虑 dp，设 $f_{i,j}$ 表示前 $i$ 列，强制第 $i$ 列第 $j$ 行被涂上，以及第 $i$ 列第 $j+1\sim m$ 行没有被涂上的方案数。（即强制涂上的区间的下端点是 $j$）</p>
<p>注意到这等于前 $i$ 列，强制第 $i$ 列第 $m-j+1$ 行被涂上，以及第 $i$ 列第 $1\sim m-j$ 行没有被涂上的方案数。（即强制涂上的区间的上端点是 $m-j+1$）</p>
<p>则从第 $i-1$ 列向第 $i$ 列转移时，考虑强制第 $i-1$ 列涂上的区间的上端点是 $k$。我们要求 $k\leq j$。</p>
<p>同时，第 $i$ 列的区间上端点可以在 $1\sim j$ 里面任意选择，于是我们得到转移式：</p>
<p>$$f_{i,j}=j\cdot\sum_{k=m-j+1}^mf_{i-1,k}$$</p>
<p>然而这是错的，因为这样可能统计到 $i-1$ 列的区间下端点在 $i$ 列的区间上端点上面的情况。</p>
<p>考虑直接把这种情况容斥掉。为了统计这种情况的数量，我们再从 $i-1$ 列的下端点考虑，得到最终的转移式：</p>
<p>$$f_{i,j}=j\cdot\sum_{k=m-j+1}^mf_{i-1,k}-\sum_{k=1}^{j-1}(j-k)f_{i-1,k}$$</p>
<p>使用一些前缀和优化，复杂度 $O(nm)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> mod, f[<span class="number">2</span>][<span class="number">10000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) f[<span class="number">1</span>][i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>, sum3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;j++) &#123;</span><br><span class="line">            sum1 = (sum1 + f[i - <span class="number">1</span> &amp; <span class="number">1</span>][m - j + <span class="number">1</span>]) % mod;</span><br><span class="line">            f[i &amp; <span class="number">1</span>][j] = (sum1 * j - sum3 + mod) % mod;</span><br><span class="line">            sum2 = (sum2 + f[i - <span class="number">1</span> &amp; <span class="number">1</span>][j]) % mod;</span><br><span class="line">            sum3 = (sum3 + sum2) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) ans = (ans + f[n &amp; <span class="number">1</span>][i]) % mod;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P9100-PA2020-Miny">P9100 [PA2020] Miny</h2>
<p>考虑 dp，设 $f_i$ 为只考虑前 $i$ 个地雷，强制第 $i$ 个不引爆的方案数，朴素想法即对于 $i$ 枚举 $j&gt;i$，判断引爆 $i+1\sim j-1$ 的所有地雷是否会引爆 $j$ 和 $i$。如果均不会引爆，则转移 $f_j\leftarrow f_j+f_i$。</p>
<p>考虑分治优化，需要在 $O(r-l)$ 时间内完成 $[l,m]$ 到 $[m+1,r]$ 的转移。</p>
<p>设 $i\leq m&lt;j$，则条件可以转化为：</p>
<ol>
<li>引爆 $i+1\sim m$ 的所有地雷不会引爆 $i$；</li>
<li>引爆 $i+1\sim m$ 的所有地雷不会引爆 $j$；</li>
<li>引爆 $m+1\sim j-1$ 的所有地雷不会引爆 $i$；</li>
<li>引爆 $m+1\sim j-1$ 的所有地雷不会引爆 $j$。</li>
</ol>
<p>注意到虽然 $i+1\sim m$ 的引爆区间的并不一定仍然是一个区间，但是由于对于所有 $i$，$i$ 的引爆区间都包含 $a_i$，所以对于任何 $i+1\leq k\leq m$，它的引爆区间向左超出 $a_{i+1}$ 的部分一定形成一个后缀（因为需要包含 $a_k&gt;a_{i+1}$），所以引爆区间的并向左超出 $a_{i+1}$ 的部分也一定形成一个后缀。同理，向右超出 $a_m$ 的部分也一定形成一个前缀。同时，我们需要判定是否属于引爆区间的并的点分别是 $a_i$ 和 $a_j$，分别向左超出 $a_{i+1}$ 和向右超出 $a_m$。</p>
<p><strong>于是在判定条件时，可以直接将引爆区间的并当作包含这个并的极小区间处理。</strong></p>
<p>而这个极小区间的左右端点就分别是所有左端点的最小值和所有右端点的最大值，可以非常容易地求出。设「包含 $i+1\sim m$ 的引爆区间的并的极小区间」是 $[L_i,R_i]$，「包含 $m+1\sim j-1$ 的引爆区间的并的极小区间」是 $[L_j’,R_j’]$。</p>
<p>然后考虑转移过程。</p>
<p>首先预处理 $i$ 侧，删去不满足 1 的 $i$（例如将其 $f$ 改为 $0$，不过当然不能把这个修改保留到最后算答案的时候）。</p>
<p>然后考虑递增处理 $j$。先判定条件 4，不满足条件 4 直接强制不能转移；然后判定条件 2,3。条件 2 等价于 $R_i&lt;a_j$。不难发现 $R_i$ 关于 $i$ 递减，于是满足条件 2 的 $i$ 是一个随 $j$ 增大而逐渐扩大的后缀。条件 3 等价于 $L_j’&gt;a_i$。类似的，不难发现 $L_j’$ 关于 $j$ 递减，于是满足条件 3 的 $i$ 是一个随 $j$ 增大而逐渐缩小的前缀。</p>
<p>于是最终合法的转移是一段区间，且左右端点均单调。使用双指针和前缀和处理，复杂度为 $O(n)$。套上分治，整个题就 $O(n\log n)$ 做完了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[N], pr[N], dp[N], ls[N], rs[N], w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cin &gt;&gt; a[i] &gt;&gt; pr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Prefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mx = <span class="number">-4e18</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mx &lt; a[i]) dp[i] = <span class="number">1</span>;</span><br><span class="line">        mx = <span class="built_in">max</span>(mx, a[i] + pr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Work</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Work</span>(l, mid);</span><br><span class="line">    ls[mid] = <span class="number">4e18</span>; rs[mid] = <span class="number">-4e18</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = mid - <span class="number">1</span>;i &gt;= l;i--) &#123;</span><br><span class="line">        ls[i] = <span class="built_in">min</span>(a[i + <span class="number">1</span>] - pr[i + <span class="number">1</span>], ls[i + <span class="number">1</span>]);</span><br><span class="line">        rs[i] = <span class="built_in">max</span>(a[i + <span class="number">1</span>] + pr[i + <span class="number">1</span>], rs[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    w[l - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l;i &lt;= mid;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ls[i] &gt; a[i]) w[i] = dp[i];</span><br><span class="line">        <span class="keyword">else</span> w[i] = <span class="number">0</span>;</span><br><span class="line">        w[i] = (w[i] + w[i - <span class="number">1</span>]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> trr = mid, trl = mid;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> lt = <span class="number">4e18</span>, rt = <span class="number">-4e18</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = mid + <span class="number">1</span>;j &lt;= r;j++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (trl &gt; l &amp;&amp; rs[trl - <span class="number">1</span>] &lt; a[j]) trl--;</span><br><span class="line">        <span class="keyword">while</span> (trr &gt;= l &amp;&amp; a[trr] &gt;= lt) trr--;</span><br><span class="line">        <span class="keyword">if</span> (trl &lt;= trr &amp;&amp; rt &lt; a[j]) dp[j] = (dp[j] + w[trr] - w[trl - <span class="number">1</span>] + mod) % mod;</span><br><span class="line">        lt = <span class="built_in">min</span>(lt, a[j] - pr[j]);</span><br><span class="line">        rt = <span class="built_in">max</span>(rt, a[j] + pr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Work</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>, mn = <span class="number">4e18</span>;</span><br><span class="line">    <span class="built_in">Work</span>(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mn &gt; a[i]) ans = (ans + dp[i]) % mod;</span><br><span class="line">        mn = <span class="built_in">min</span>(mn, a[i] - pr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P9110-PA2020-Samochody-dostawcze">P9110 [PA2020] Samochody dostawcze</h2>
<p>对于所有运输计划 $(r_i,t_i,w_i)$，按 $t_i-w_i$ 分类。</p>
<p>分类后，任意一类里面任意一个横的和任意一个竖的都会撞上，则我们只能取消全部横的或者取消全部竖的，于是取消尽量少的即可。</p>
<p>复杂度 $O(n)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, cnt[<span class="number">3000005</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">qread</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">qread</span>(), w = <span class="built_in">qread</span>(), t = <span class="built_in">qread</span>();</span><br><span class="line">        cnt[t - w + <span class="number">1000005</span>][r - <span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">3000000</span>;i++) ans += <span class="built_in">min</span>(cnt[i][<span class="number">0</span>], cnt[i][<span class="number">1</span>]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://soly5tic.github.io/2023/06/05/pa2020-joisc2020-ejoi2021-upsolve/" data-id="cm6m8kxld000xd0vh5l87e68m" data-title="PA2020 / JOISC2020 / eJOI2021 选做" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
        <a href="/2023/06/05/pa2020-joisc2020-ejoi2021-upsolve/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count fa fa-comment" data-xid="/2023/06/05/pa2020-joisc2020-ejoi2021-upsolve/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%A2%98%E8%A7%A3/" rel="tag">题解</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/06/25/2023-ustc-notes/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Adverse Prelude - 2023 高考 &amp; 2023 USTC 少创班
        
      </div>
    </a>
  
  
    <a href="/2023/05/29/pkucpc-2023-notes/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">PKUCPC 2023</div>
    </a>
  
</nav>

  
</article>



  <section id="comments" class="vcomment">

  </section>
</section>
        
          <aside id="sidebar">
  
      <div class="widget-wrap">
    <h3 class="widget-title">Friends</h3>
    <div class="widget">
      <ul>
        <li>
          <a target="_blank" rel="noopener" href="https://www.blog-e.top/">Blog-E</a>
        </li>
      </ul>
    </div>
  </div>
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B4%E6%B4%BB/" rel="tag">整活</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%B8%E8%AE%B0/" rel="tag">游记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A2%98%E8%A7%A3/" rel="tag">题解</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 13.33px;">总结</a> <a href="/tags/%E6%95%B4%E6%B4%BB/" style="font-size: 10px;">整活</a> <a href="/tags/%E6%B8%B8%E8%AE%B0/" style="font-size: 16.67px;">游记</a> <a href="/tags/%E9%A2%98%E8%A7%A3/" style="font-size: 20px;">题解</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">February 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/12/29/icpc49-ecf/">第 49 届 ICPC EC Final 游记</a>
          </li>
        
          <li>
            <a href="/2024/12/01/icpc49-regional-km/">ICPC 昆明站游记</a>
          </li>
        
          <li>
            <a href="/2024/11/18/icpc49-regional-sh/">ICPC 上海站游记</a>
          </li>
        
          <li>
            <a href="/2024/11/09/ccpc10-regional-cq/">CCPC 重庆站游记</a>
          </li>
        
          <li>
            <a href="/2024/10/15/ucup3-s12/">The 3rd Universal Cup Stage 12 记录</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    <div class="widget-wrap">
    <h3 class="widget-title">Page Views</h3>
          <img src="https://badges.toozhao.com/badges/01HN5MV9JDS57RZF30YTKM0DVY/green.svg" alt="Page Views Count">
  </div>
  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 Sol 1<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>

<script>
    var GUEST_INFO = ['nick','mail','link'];
    var guest_info = 'nick,mail,link'.split(',').filter(function(item){
        return GUEST_INFO.indexOf(item) > -1
    });
    var notify = 'false' == true;
    var verify = 'false' == true;
    new Valine({
        el: '.vcomment',
        notify: notify,
        verify: verify,
        appId: "eCOqy671NBhdnqpII5jCnb9f-gzGzoHsz",
        appKey: "OWLPWcS3Bjm5x1YJG144u61I",
        placeholder: "Just go go",
        pageSize:'10',
        avatar:'mm',
        lang:'zh-cn'
    });
</script>

  </div>
</body>
</html>